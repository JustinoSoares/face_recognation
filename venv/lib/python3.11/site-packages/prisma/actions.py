# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off
from __future__ import annotations

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template actions.py.jinja --
from typing import TypeVar
import warnings

from . import types, errors, bases
from ._compat import model_parse
from ._constants import CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED

if TYPE_CHECKING:
    from .client import Prisma
    from .bases import _PrismaModel


_PrismaModelT = TypeVar('_PrismaModelT', bound='_PrismaModel')


class AlunosActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Alunos]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Alunos.prisma().query_raw(
            'SELECT * FROM Alunos WHERE id = $1',
            1103527590,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Alunos
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Alunos.prisma().query_first(
            'SELECT * FROM Alunos WHERE n_do_processo = $1',
            377401575,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.AlunosCreateInput,
        include: Optional[types.AlunosInclude] = None
    ) -> _PrismaModelT:
        """Create a new Alunos record.

        Parameters
        ----------
        data
            Alunos record data
        include
            Specifies which relations should be loaded on the returned Alunos model

        Returns
        -------
        prisma.models.Alunos
            The created Alunos record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Alunos record from just the required fields
        alunos = await Alunos.prisma().create(
            data={
                # data to create a Alunos record
                'n_do_processo': 662824084,
                'nome_completo': 'bbehjachib',
                'classe': 'cadfabfehe',
                'ano_letivo': 'dgiiaaijj',
                'turma': 'bfaiacjjfc',
                'curso': 'eigcfgbif',
                'createdAt': datetime.datetime.utcnow(),
                'updatedAt': datetime.datetime.utcnow(),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.AlunosCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Alunos records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Alunos record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Alunos.prisma().create_many(
            data=[
                {
                    # data to create a Alunos record
                    'n_do_processo': 1062517886,
                    'nome_completo': 'cghideieh',
                    'classe': 'biabhbdai',
                    'ano_letivo': 'idghgaicb',
                    'turma': 'fjfddhigg',
                    'curso': 'hjaecfifb',
                    'createdAt': datetime.datetime.utcnow(),
                    'updatedAt': datetime.datetime.utcnow(),
                },
                {
                    # data to create a Alunos record
                    'n_do_processo': 2111915288,
                    'nome_completo': 'bbejhfidcb',
                    'classe': 'bgeecijdgg',
                    'ano_letivo': 'bdiicjafbj',
                    'turma': 'bgehebiafc',
                    'curso': 'bghffegacj',
                    'createdAt': datetime.datetime.utcnow(),
                    'updatedAt': datetime.datetime.utcnow(),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.AlunosWhereUniqueInput,
        include: Optional[types.AlunosInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Alunos record.

        Parameters
        ----------
        where
            Alunos filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Alunos model

        Returns
        -------
        prisma.models.Alunos
            The deleted Alunos record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        alunos = await Alunos.prisma().delete(
            where={
                'id': 1767274722,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.AlunosWhereUniqueInput,
        include: Optional[types.AlunosInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Alunos record.

        Parameters
        ----------
        where
            Alunos filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Alunos model

        Returns
        -------
        prisma.models.Alunos
            The found Alunos record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        alunos = await Alunos.prisma().find_unique(
            where={
                'id': 326272115,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.AlunosWhereUniqueInput,
        include: Optional[types.AlunosInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Alunos record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Alunos filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Alunos model

        Returns
        -------
        prisma.models.Alunos
            The found Alunos record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        alunos = await Alunos.prisma().find_unique_or_raise(
            where={
                'id': 1343201072,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AlunosWhereInput] = None,
        cursor: Optional[types.AlunosWhereUniqueInput] = None,
        include: Optional[types.AlunosInclude] = None,
        order: Optional[Union[types.AlunosOrderByInput, List[types.AlunosOrderByInput]]] = None,
        distinct: Optional[List[types.AlunosScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Alunos records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Alunos records returned
        skip
            Ignore the first N results
        where
            Alunos filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Alunos model
        order
            Order the returned Alunos records by any field
        distinct
            Filter Alunos records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Alunos]
            The list of all Alunos records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Alunos records
        alunos = await Alunos.prisma().find_many(take=10)

        # find the first 5 Alunos records ordered by the nome_completo field
        alunos = await Alunos.prisma().find_many(
            take=5,
            order={
                'nome_completo': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AlunosWhereInput] = None,
        cursor: Optional[types.AlunosWhereUniqueInput] = None,
        include: Optional[types.AlunosInclude] = None,
        order: Optional[Union[types.AlunosOrderByInput, List[types.AlunosOrderByInput]]] = None,
        distinct: Optional[List[types.AlunosScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Alunos record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Alunos filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Alunos model
        order
            Order the returned Alunos records by any field
        distinct
            Filter Alunos records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Alunos
            The first Alunos record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Alunos record ordered by the classe field
        alunos = await Alunos.prisma().find_first(
            skip=1,
            order={
                'classe': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AlunosWhereInput] = None,
        cursor: Optional[types.AlunosWhereUniqueInput] = None,
        include: Optional[types.AlunosInclude] = None,
        order: Optional[Union[types.AlunosOrderByInput, List[types.AlunosOrderByInput]]] = None,
        distinct: Optional[List[types.AlunosScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Alunos record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Alunos filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Alunos model
        order
            Order the returned Alunos records by any field
        distinct
            Filter Alunos records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Alunos
            The first Alunos record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Alunos record ordered by the turno field
        alunos = await Alunos.prisma().find_first_or_raise(
            skip=1,
            order={
                'turno': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.AlunosUpdateInput,
        where: types.AlunosWhereUniqueInput,
        include: Optional[types.AlunosInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Alunos record.

        Parameters
        ----------
        data
            Alunos record data specifying what to update
        where
            Alunos filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Alunos model

        Returns
        -------
        prisma.models.Alunos
            The updated Alunos record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        alunos = await Alunos.prisma().update(
            where={
                'id': 675780521,
            },
            data={
                # data to update the Alunos record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.AlunosWhereUniqueInput,
        data: types.AlunosUpsertInput,
        include: Optional[types.AlunosInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Alunos filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Alunos model

        Returns
        -------
        prisma.models.Alunos
            The created or updated Alunos record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        alunos = await Alunos.prisma().upsert(
            where={
                'id': 744964398,
            },
            data={
                'create': {
                    'id': 744964398,
                    'n_do_processo': 2111915288,
                    'nome_completo': 'bbejhfidcb',
                    'classe': 'bgeecijdgg',
                    'ano_letivo': 'bdiicjafbj',
                    'turma': 'bgehebiafc',
                    'curso': 'bghffegacj',
                    'createdAt': datetime.datetime.utcnow(),
                    'updatedAt': datetime.datetime.utcnow(),
                },
                'update': {
                    'n_do_processo': 2111915288,
                    'nome_completo': 'bbejhfidcb',
                    'classe': 'bgeecijdgg',
                    'ano_letivo': 'bdiicjafbj',
                    'turma': 'bgehebiafc',
                    'curso': 'bghffegacj',
                    'createdAt': datetime.datetime.utcnow(),
                    'updatedAt': datetime.datetime.utcnow(),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.AlunosUpdateManyMutationInput,
        where: types.AlunosWhereInput,
    ) -> int:
        """Update multiple Alunos records

        Parameters
        ----------
        data
            Alunos data to update the selected Alunos records to
        where
            Filter to select the Alunos records to update

        Returns
        -------
        int
            The total number of Alunos records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Alunos records
        total = await Alunos.prisma().update_many(
            data={
                'ano_letivo': 'bjgjgibgbf'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AlunosWhereInput] = None,
        cursor: Optional[types.AlunosWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Alunos records present in the database

        Parameters
        ----------
        select
            Select the Alunos fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Alunos filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AlunosCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Alunos.prisma().count()

        # results: prisma.types.AlunosCountAggregateOutput
        results = await Alunos.prisma().count(
            select={
                '_all': True,
                'turma': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.AlunosCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AlunosWhereInput] = None,
        cursor: Optional[types.AlunosWhereUniqueInput] = None,
    ) -> types.AlunosCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.AlunosCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AlunosWhereInput] = None,
        cursor: Optional[types.AlunosWhereUniqueInput] = None,
    ) -> Union[int, types.AlunosCountAggregateOutput]:
        """Count the number of Alunos records present in the database

        Parameters
        ----------
        select
            Select the Alunos fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Alunos filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AlunosCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Alunos.prisma().count()

        # results: prisma.types.AlunosCountAggregateOutput
        results = await Alunos.prisma().count(
            select={
                '_all': True,
                'curso': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.AlunosCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.AlunosWhereInput] = None
    ) -> int:
        """Delete multiple Alunos records.

        Parameters
        ----------
        where
            Optional Alunos filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Alunos records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Alunos records
        total = await Alunos.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.AlunosScalarFieldKeys'],
        *,
        where: Optional['types.AlunosWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.AlunosAvgAggregateInput'] = None,
        sum: Optional['types.AlunosSumAggregateInput'] = None,
        min: Optional['types.AlunosMinAggregateInput'] = None,
        max: Optional['types.AlunosMaxAggregateInput'] = None,
        having: Optional['types.AlunosScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.AlunosCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.AlunosScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.AlunosScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.AlunosGroupByOutput']:
        """Group Alunos records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Alunos fields to group records by
        where
            Alunos filter to select records
        take
            Limit the maximum number of Alunos records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.AlunosGroupByOutput]
            A list of dictionaries representing the Alunos record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Alunos records by createdAt values
        # and count how many records are in each group
        results = await Alunos.prisma().group_by(
            ['createdAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class Alunos_propinaActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Alunos_propina]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Alunos_propina.prisma().query_raw(
            'SELECT * FROM Alunos_propina WHERE id = $1',
            1116175964,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Alunos_propina
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Alunos_propina.prisma().query_first(
            'SELECT * FROM Alunos_propina WHERE alunoId = $1',
            861472101,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.Alunos_propinaCreateInput,
        include: Optional[types.Alunos_propinaInclude] = None
    ) -> _PrismaModelT:
        """Create a new Alunos_propina record.

        Parameters
        ----------
        data
            Alunos_propina record data
        include
            Specifies which relations should be loaded on the returned Alunos_propina model

        Returns
        -------
        prisma.models.Alunos_propina
            The created Alunos_propina record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Alunos_propina record from just the required fields
        alunos_propina = await Alunos_propina.prisma().create(
            data={
                # data to create a Alunos_propina record
                'valor': 'bdadaadhag',
                'createdAt': datetime.datetime.utcnow(),
                'updatedAt': datetime.datetime.utcnow(),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.Alunos_propinaCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Alunos_propina records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Alunos_propina record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Alunos_propina.prisma().create_many(
            data=[
                {
                    # data to create a Alunos_propina record
                    'valor': 'bgiggdidbf',
                    'createdAt': datetime.datetime.utcnow(),
                    'updatedAt': datetime.datetime.utcnow(),
                },
                {
                    # data to create a Alunos_propina record
                    'valor': 'caaaedabfc',
                    'createdAt': datetime.datetime.utcnow(),
                    'updatedAt': datetime.datetime.utcnow(),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.Alunos_propinaWhereUniqueInput,
        include: Optional[types.Alunos_propinaInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Alunos_propina record.

        Parameters
        ----------
        where
            Alunos_propina filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Alunos_propina model

        Returns
        -------
        prisma.models.Alunos_propina
            The deleted Alunos_propina record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        alunos_propina = await Alunos_propina.prisma().delete(
            where={
                'id': 1868141281,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.Alunos_propinaWhereUniqueInput,
        include: Optional[types.Alunos_propinaInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Alunos_propina record.

        Parameters
        ----------
        where
            Alunos_propina filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Alunos_propina model

        Returns
        -------
        prisma.models.Alunos_propina
            The found Alunos_propina record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        alunos_propina = await Alunos_propina.prisma().find_unique(
            where={
                'id': 1860847622,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.Alunos_propinaWhereUniqueInput,
        include: Optional[types.Alunos_propinaInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Alunos_propina record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Alunos_propina filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Alunos_propina model

        Returns
        -------
        prisma.models.Alunos_propina
            The found Alunos_propina record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        alunos_propina = await Alunos_propina.prisma().find_unique_or_raise(
            where={
                'id': 1448521415,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.Alunos_propinaWhereInput] = None,
        cursor: Optional[types.Alunos_propinaWhereUniqueInput] = None,
        include: Optional[types.Alunos_propinaInclude] = None,
        order: Optional[Union[types.Alunos_propinaOrderByInput, List[types.Alunos_propinaOrderByInput]]] = None,
        distinct: Optional[List[types.Alunos_propinaScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Alunos_propina records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Alunos_propina records returned
        skip
            Ignore the first N results
        where
            Alunos_propina filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Alunos_propina model
        order
            Order the returned Alunos_propina records by any field
        distinct
            Filter Alunos_propina records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Alunos_propina]
            The list of all Alunos_propina records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Alunos_propina records
        alunos_propinas = await Alunos_propina.prisma().find_many(take=10)

        # find the first 5 Alunos_propina records ordered by the propinaId field
        alunos_propinas = await Alunos_propina.prisma().find_many(
            take=5,
            order={
                'propinaId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.Alunos_propinaWhereInput] = None,
        cursor: Optional[types.Alunos_propinaWhereUniqueInput] = None,
        include: Optional[types.Alunos_propinaInclude] = None,
        order: Optional[Union[types.Alunos_propinaOrderByInput, List[types.Alunos_propinaOrderByInput]]] = None,
        distinct: Optional[List[types.Alunos_propinaScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Alunos_propina record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Alunos_propina filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Alunos_propina model
        order
            Order the returned Alunos_propina records by any field
        distinct
            Filter Alunos_propina records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Alunos_propina
            The first Alunos_propina record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Alunos_propina record ordered by the valor field
        alunos_propina = await Alunos_propina.prisma().find_first(
            skip=1,
            order={
                'valor': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.Alunos_propinaWhereInput] = None,
        cursor: Optional[types.Alunos_propinaWhereUniqueInput] = None,
        include: Optional[types.Alunos_propinaInclude] = None,
        order: Optional[Union[types.Alunos_propinaOrderByInput, List[types.Alunos_propinaOrderByInput]]] = None,
        distinct: Optional[List[types.Alunos_propinaScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Alunos_propina record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Alunos_propina filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Alunos_propina model
        order
            Order the returned Alunos_propina records by any field
        distinct
            Filter Alunos_propina records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Alunos_propina
            The first Alunos_propina record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Alunos_propina record ordered by the createdAt field
        alunos_propina = await Alunos_propina.prisma().find_first_or_raise(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.Alunos_propinaUpdateInput,
        where: types.Alunos_propinaWhereUniqueInput,
        include: Optional[types.Alunos_propinaInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Alunos_propina record.

        Parameters
        ----------
        data
            Alunos_propina record data specifying what to update
        where
            Alunos_propina filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Alunos_propina model

        Returns
        -------
        prisma.models.Alunos_propina
            The updated Alunos_propina record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        alunos_propina = await Alunos_propina.prisma().update(
            where={
                'id': 1628650740,
            },
            data={
                # data to update the Alunos_propina record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.Alunos_propinaWhereUniqueInput,
        data: types.Alunos_propinaUpsertInput,
        include: Optional[types.Alunos_propinaInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Alunos_propina filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Alunos_propina model

        Returns
        -------
        prisma.models.Alunos_propina
            The created or updated Alunos_propina record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        alunos_propina = await Alunos_propina.prisma().upsert(
            where={
                'id': 1249606685,
            },
            data={
                'create': {
                    'id': 1249606685,
                    'valor': 'caaaedabfc',
                    'createdAt': datetime.datetime.utcnow(),
                    'updatedAt': datetime.datetime.utcnow(),
                },
                'update': {
                    'valor': 'caaaedabfc',
                    'createdAt': datetime.datetime.utcnow(),
                    'updatedAt': datetime.datetime.utcnow(),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.Alunos_propinaUpdateManyMutationInput,
        where: types.Alunos_propinaWhereInput,
    ) -> int:
        """Update multiple Alunos_propina records

        Parameters
        ----------
        data
            Alunos_propina data to update the selected Alunos_propina records to
        where
            Filter to select the Alunos_propina records to update

        Returns
        -------
        int
            The total number of Alunos_propina records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Alunos_propina records
        total = await Alunos_propina.prisma().update_many(
            data={
                'updatedAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.Alunos_propinaWhereInput] = None,
        cursor: Optional[types.Alunos_propinaWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Alunos_propina records present in the database

        Parameters
        ----------
        select
            Select the Alunos_propina fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Alunos_propina filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.Alunos_propinaCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Alunos_propina.prisma().count()

        # results: prisma.types.Alunos_propinaCountAggregateOutput
        results = await Alunos_propina.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.Alunos_propinaCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.Alunos_propinaWhereInput] = None,
        cursor: Optional[types.Alunos_propinaWhereUniqueInput] = None,
    ) -> types.Alunos_propinaCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.Alunos_propinaCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.Alunos_propinaWhereInput] = None,
        cursor: Optional[types.Alunos_propinaWhereUniqueInput] = None,
    ) -> Union[int, types.Alunos_propinaCountAggregateOutput]:
        """Count the number of Alunos_propina records present in the database

        Parameters
        ----------
        select
            Select the Alunos_propina fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Alunos_propina filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.Alunos_propinaCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Alunos_propina.prisma().count()

        # results: prisma.types.Alunos_propinaCountAggregateOutput
        results = await Alunos_propina.prisma().count(
            select={
                '_all': True,
                'alunoId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.Alunos_propinaCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.Alunos_propinaWhereInput] = None
    ) -> int:
        """Delete multiple Alunos_propina records.

        Parameters
        ----------
        where
            Optional Alunos_propina filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Alunos_propina records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Alunos_propina records
        total = await Alunos_propina.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.Alunos_propinaScalarFieldKeys'],
        *,
        where: Optional['types.Alunos_propinaWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.Alunos_propinaAvgAggregateInput'] = None,
        sum: Optional['types.Alunos_propinaSumAggregateInput'] = None,
        min: Optional['types.Alunos_propinaMinAggregateInput'] = None,
        max: Optional['types.Alunos_propinaMaxAggregateInput'] = None,
        having: Optional['types.Alunos_propinaScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.Alunos_propinaCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.Alunos_propinaScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.Alunos_propinaScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.Alunos_propinaGroupByOutput']:
        """Group Alunos_propina records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Alunos_propina fields to group records by
        where
            Alunos_propina filter to select records
        take
            Limit the maximum number of Alunos_propina records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.Alunos_propinaGroupByOutput]
            A list of dictionaries representing the Alunos_propina record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Alunos_propina records by propinaId values
        # and count how many records are in each group
        results = await Alunos_propina.prisma().group_by(
            ['propinaId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class FotosActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Fotos]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Fotos.prisma().query_raw(
            'SELECT * FROM Fotos WHERE id = $1',
            835903122,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Fotos
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Fotos.prisma().query_first(
            'SELECT * FROM Fotos WHERE descricao = $1',
            'hgdhbjhhj',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.FotosCreateInput,
        include: Optional[types.FotosInclude] = None
    ) -> _PrismaModelT:
        """Create a new Fotos record.

        Parameters
        ----------
        data
            Fotos record data
        include
            Specifies which relations should be loaded on the returned Fotos model

        Returns
        -------
        prisma.models.Fotos
            The created Fotos record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Fotos record from just the required fields
        fotos = await Fotos.prisma().create(
            data={
                # data to create a Fotos record
                'url': 'ecjjjfbae',
                'createdAt': datetime.datetime.utcnow(),
                'updatedAt': datetime.datetime.utcnow(),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.FotosCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Fotos records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Fotos record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Fotos.prisma().create_many(
            data=[
                {
                    # data to create a Fotos record
                    'url': 'bhhfibbigf',
                    'createdAt': datetime.datetime.utcnow(),
                    'updatedAt': datetime.datetime.utcnow(),
                },
                {
                    # data to create a Fotos record
                    'url': 'ijdbeffgg',
                    'createdAt': datetime.datetime.utcnow(),
                    'updatedAt': datetime.datetime.utcnow(),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.FotosWhereUniqueInput,
        include: Optional[types.FotosInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Fotos record.

        Parameters
        ----------
        where
            Fotos filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Fotos model

        Returns
        -------
        prisma.models.Fotos
            The deleted Fotos record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        fotos = await Fotos.prisma().delete(
            where={
                'id': 995405759,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.FotosWhereUniqueInput,
        include: Optional[types.FotosInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Fotos record.

        Parameters
        ----------
        where
            Fotos filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Fotos model

        Returns
        -------
        prisma.models.Fotos
            The found Fotos record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        fotos = await Fotos.prisma().find_unique(
            where={
                'id': 2102736524,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.FotosWhereUniqueInput,
        include: Optional[types.FotosInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Fotos record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Fotos filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Fotos model

        Returns
        -------
        prisma.models.Fotos
            The found Fotos record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        fotos = await Fotos.prisma().find_unique_or_raise(
            where={
                'id': 271520213,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.FotosWhereInput] = None,
        cursor: Optional[types.FotosWhereUniqueInput] = None,
        include: Optional[types.FotosInclude] = None,
        order: Optional[Union[types.FotosOrderByInput, List[types.FotosOrderByInput]]] = None,
        distinct: Optional[List[types.FotosScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Fotos records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Fotos records returned
        skip
            Ignore the first N results
        where
            Fotos filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Fotos model
        order
            Order the returned Fotos records by any field
        distinct
            Filter Fotos records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Fotos]
            The list of all Fotos records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Fotos records
        fotos = await Fotos.prisma().find_many(take=10)

        # find the first 5 Fotos records ordered by the url field
        fotos = await Fotos.prisma().find_many(
            take=5,
            order={
                'url': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.FotosWhereInput] = None,
        cursor: Optional[types.FotosWhereUniqueInput] = None,
        include: Optional[types.FotosInclude] = None,
        order: Optional[Union[types.FotosOrderByInput, List[types.FotosOrderByInput]]] = None,
        distinct: Optional[List[types.FotosScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Fotos record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Fotos filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Fotos model
        order
            Order the returned Fotos records by any field
        distinct
            Filter Fotos records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Fotos
            The first Fotos record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Fotos record ordered by the alunoId field
        fotos = await Fotos.prisma().find_first(
            skip=1,
            order={
                'alunoId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.FotosWhereInput] = None,
        cursor: Optional[types.FotosWhereUniqueInput] = None,
        include: Optional[types.FotosInclude] = None,
        order: Optional[Union[types.FotosOrderByInput, List[types.FotosOrderByInput]]] = None,
        distinct: Optional[List[types.FotosScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Fotos record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Fotos filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Fotos model
        order
            Order the returned Fotos records by any field
        distinct
            Filter Fotos records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Fotos
            The first Fotos record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Fotos record ordered by the createdAt field
        fotos = await Fotos.prisma().find_first_or_raise(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.FotosUpdateInput,
        where: types.FotosWhereUniqueInput,
        include: Optional[types.FotosInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Fotos record.

        Parameters
        ----------
        data
            Fotos record data specifying what to update
        where
            Fotos filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Fotos model

        Returns
        -------
        prisma.models.Fotos
            The updated Fotos record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        fotos = await Fotos.prisma().update(
            where={
                'id': 456633834,
            },
            data={
                # data to update the Fotos record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.FotosWhereUniqueInput,
        data: types.FotosUpsertInput,
        include: Optional[types.FotosInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Fotos filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Fotos model

        Returns
        -------
        prisma.models.Fotos
            The created or updated Fotos record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        fotos = await Fotos.prisma().upsert(
            where={
                'id': 2058258651,
            },
            data={
                'create': {
                    'id': 2058258651,
                    'url': 'ijdbeffgg',
                    'createdAt': datetime.datetime.utcnow(),
                    'updatedAt': datetime.datetime.utcnow(),
                },
                'update': {
                    'url': 'ijdbeffgg',
                    'createdAt': datetime.datetime.utcnow(),
                    'updatedAt': datetime.datetime.utcnow(),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.FotosUpdateManyMutationInput,
        where: types.FotosWhereInput,
    ) -> int:
        """Update multiple Fotos records

        Parameters
        ----------
        data
            Fotos data to update the selected Fotos records to
        where
            Filter to select the Fotos records to update

        Returns
        -------
        int
            The total number of Fotos records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Fotos records
        total = await Fotos.prisma().update_many(
            data={
                'updatedAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.FotosWhereInput] = None,
        cursor: Optional[types.FotosWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Fotos records present in the database

        Parameters
        ----------
        select
            Select the Fotos fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Fotos filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.FotosCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Fotos.prisma().count()

        # results: prisma.types.FotosCountAggregateOutput
        results = await Fotos.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.FotosCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.FotosWhereInput] = None,
        cursor: Optional[types.FotosWhereUniqueInput] = None,
    ) -> types.FotosCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.FotosCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.FotosWhereInput] = None,
        cursor: Optional[types.FotosWhereUniqueInput] = None,
    ) -> Union[int, types.FotosCountAggregateOutput]:
        """Count the number of Fotos records present in the database

        Parameters
        ----------
        select
            Select the Fotos fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Fotos filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.FotosCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Fotos.prisma().count()

        # results: prisma.types.FotosCountAggregateOutput
        results = await Fotos.prisma().count(
            select={
                '_all': True,
                'descricao': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.FotosCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.FotosWhereInput] = None
    ) -> int:
        """Delete multiple Fotos records.

        Parameters
        ----------
        where
            Optional Fotos filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Fotos records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Fotos records
        total = await Fotos.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.FotosScalarFieldKeys'],
        *,
        where: Optional['types.FotosWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.FotosAvgAggregateInput'] = None,
        sum: Optional['types.FotosSumAggregateInput'] = None,
        min: Optional['types.FotosMinAggregateInput'] = None,
        max: Optional['types.FotosMaxAggregateInput'] = None,
        having: Optional['types.FotosScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.FotosCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.FotosScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.FotosScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.FotosGroupByOutput']:
        """Group Fotos records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Fotos fields to group records by
        where
            Fotos filter to select records
        take
            Limit the maximum number of Fotos records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.FotosGroupByOutput]
            A list of dictionaries representing the Fotos record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Fotos records by url values
        # and count how many records are in each group
        results = await Fotos.prisma().group_by(
            ['url'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class HistoricoActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Historico]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Historico.prisma().query_raw(
            'SELECT * FROM Historico WHERE id = $1',
            1583689592,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Historico
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Historico.prisma().query_first(
            'SELECT * FROM Historico WHERE alunoId = $1',
            878442065,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.HistoricoCreateInput,
        include: Optional[types.HistoricoInclude] = None
    ) -> _PrismaModelT:
        """Create a new Historico record.

        Parameters
        ----------
        data
            Historico record data
        include
            Specifies which relations should be loaded on the returned Historico model

        Returns
        -------
        prisma.models.Historico
            The created Historico record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Historico record from just the required fields
        historico = await Historico.prisma().create(
            data={
                # data to create a Historico record
                'status': enums.enum_Historico_status.Permitido,
                'timestamp': datetime.datetime.utcnow(),
                'createdAt': datetime.datetime.utcnow(),
                'updatedAt': datetime.datetime.utcnow(),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.HistoricoCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Historico records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Historico record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Historico.prisma().create_many(
            data=[
                {
                    # data to create a Historico record
                    'status': enums.enum_Historico_status.Permitido,
                    'timestamp': datetime.datetime.utcnow(),
                    'createdAt': datetime.datetime.utcnow(),
                    'updatedAt': datetime.datetime.utcnow(),
                },
                {
                    # data to create a Historico record
                    'status': enums.enum_Historico_status.Permitido,
                    'timestamp': datetime.datetime.utcnow(),
                    'createdAt': datetime.datetime.utcnow(),
                    'updatedAt': datetime.datetime.utcnow(),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.HistoricoWhereUniqueInput,
        include: Optional[types.HistoricoInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Historico record.

        Parameters
        ----------
        where
            Historico filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Historico model

        Returns
        -------
        prisma.models.Historico
            The deleted Historico record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        historico = await Historico.prisma().delete(
            where={
                'id': 1675280054,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.HistoricoWhereUniqueInput,
        include: Optional[types.HistoricoInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Historico record.

        Parameters
        ----------
        where
            Historico filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Historico model

        Returns
        -------
        prisma.models.Historico
            The found Historico record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        historico = await Historico.prisma().find_unique(
            where={
                'id': 1627576247,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.HistoricoWhereUniqueInput,
        include: Optional[types.HistoricoInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Historico record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Historico filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Historico model

        Returns
        -------
        prisma.models.Historico
            The found Historico record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        historico = await Historico.prisma().find_unique_or_raise(
            where={
                'id': 2054802212,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.HistoricoWhereInput] = None,
        cursor: Optional[types.HistoricoWhereUniqueInput] = None,
        include: Optional[types.HistoricoInclude] = None,
        order: Optional[Union[types.HistoricoOrderByInput, List[types.HistoricoOrderByInput]]] = None,
        distinct: Optional[List[types.HistoricoScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Historico records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Historico records returned
        skip
            Ignore the first N results
        where
            Historico filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Historico model
        order
            Order the returned Historico records by any field
        distinct
            Filter Historico records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Historico]
            The list of all Historico records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Historico records
        historicos = await Historico.prisma().find_many(take=10)

        # find the first 5 Historico records ordered by the propinaId field
        historicos = await Historico.prisma().find_many(
            take=5,
            order={
                'propinaId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.HistoricoWhereInput] = None,
        cursor: Optional[types.HistoricoWhereUniqueInput] = None,
        include: Optional[types.HistoricoInclude] = None,
        order: Optional[Union[types.HistoricoOrderByInput, List[types.HistoricoOrderByInput]]] = None,
        distinct: Optional[List[types.HistoricoScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Historico record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Historico filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Historico model
        order
            Order the returned Historico records by any field
        distinct
            Filter Historico records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Historico
            The first Historico record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Historico record ordered by the status field
        historico = await Historico.prisma().find_first(
            skip=1,
            order={
                'status': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.HistoricoWhereInput] = None,
        cursor: Optional[types.HistoricoWhereUniqueInput] = None,
        include: Optional[types.HistoricoInclude] = None,
        order: Optional[Union[types.HistoricoOrderByInput, List[types.HistoricoOrderByInput]]] = None,
        distinct: Optional[List[types.HistoricoScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Historico record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Historico filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Historico model
        order
            Order the returned Historico records by any field
        distinct
            Filter Historico records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Historico
            The first Historico record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Historico record ordered by the timestamp field
        historico = await Historico.prisma().find_first_or_raise(
            skip=1,
            order={
                'timestamp': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.HistoricoUpdateInput,
        where: types.HistoricoWhereUniqueInput,
        include: Optional[types.HistoricoInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Historico record.

        Parameters
        ----------
        data
            Historico record data specifying what to update
        where
            Historico filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Historico model

        Returns
        -------
        prisma.models.Historico
            The updated Historico record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        historico = await Historico.prisma().update(
            where={
                'id': 60335757,
            },
            data={
                # data to update the Historico record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.HistoricoWhereUniqueInput,
        data: types.HistoricoUpsertInput,
        include: Optional[types.HistoricoInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Historico filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Historico model

        Returns
        -------
        prisma.models.Historico
            The created or updated Historico record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        historico = await Historico.prisma().upsert(
            where={
                'id': 684462146,
            },
            data={
                'create': {
                    'id': 684462146,
                    'status': enums.enum_Historico_status.Permitido,
                    'timestamp': datetime.datetime.utcnow(),
                    'createdAt': datetime.datetime.utcnow(),
                    'updatedAt': datetime.datetime.utcnow(),
                },
                'update': {
                    'status': enums.enum_Historico_status.Permitido,
                    'timestamp': datetime.datetime.utcnow(),
                    'createdAt': datetime.datetime.utcnow(),
                    'updatedAt': datetime.datetime.utcnow(),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.HistoricoUpdateManyMutationInput,
        where: types.HistoricoWhereInput,
    ) -> int:
        """Update multiple Historico records

        Parameters
        ----------
        data
            Historico data to update the selected Historico records to
        where
            Filter to select the Historico records to update

        Returns
        -------
        int
            The total number of Historico records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Historico records
        total = await Historico.prisma().update_many(
            data={
                'createdAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.HistoricoWhereInput] = None,
        cursor: Optional[types.HistoricoWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Historico records present in the database

        Parameters
        ----------
        select
            Select the Historico fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Historico filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.HistoricoCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Historico.prisma().count()

        # results: prisma.types.HistoricoCountAggregateOutput
        results = await Historico.prisma().count(
            select={
                '_all': True,
                'updatedAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.HistoricoCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.HistoricoWhereInput] = None,
        cursor: Optional[types.HistoricoWhereUniqueInput] = None,
    ) -> types.HistoricoCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.HistoricoCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.HistoricoWhereInput] = None,
        cursor: Optional[types.HistoricoWhereUniqueInput] = None,
    ) -> Union[int, types.HistoricoCountAggregateOutput]:
        """Count the number of Historico records present in the database

        Parameters
        ----------
        select
            Select the Historico fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Historico filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.HistoricoCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Historico.prisma().count()

        # results: prisma.types.HistoricoCountAggregateOutput
        results = await Historico.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.HistoricoCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.HistoricoWhereInput] = None
    ) -> int:
        """Delete multiple Historico records.

        Parameters
        ----------
        where
            Optional Historico filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Historico records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Historico records
        total = await Historico.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.HistoricoScalarFieldKeys'],
        *,
        where: Optional['types.HistoricoWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.HistoricoAvgAggregateInput'] = None,
        sum: Optional['types.HistoricoSumAggregateInput'] = None,
        min: Optional['types.HistoricoMinAggregateInput'] = None,
        max: Optional['types.HistoricoMaxAggregateInput'] = None,
        having: Optional['types.HistoricoScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.HistoricoCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.HistoricoScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.HistoricoScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.HistoricoGroupByOutput']:
        """Group Historico records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Historico fields to group records by
        where
            Historico filter to select records
        take
            Limit the maximum number of Historico records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.HistoricoGroupByOutput]
            A list of dictionaries representing the Historico record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Historico records by alunoId values
        # and count how many records are in each group
        results = await Historico.prisma().group_by(
            ['alunoId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class PropinasActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Propinas]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Propinas.prisma().query_raw(
            'SELECT * FROM Propinas WHERE id = $1',
            1625503827,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Propinas
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Propinas.prisma().query_first(
            'SELECT * FROM Propinas WHERE mes = $1',
            enums.enum_Propinas_mes.Janeiro,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.PropinasCreateInput,
        include: Optional[types.PropinasInclude] = None
    ) -> _PrismaModelT:
        """Create a new Propinas record.

        Parameters
        ----------
        data
            Propinas record data
        include
            Specifies which relations should be loaded on the returned Propinas model

        Returns
        -------
        prisma.models.Propinas
            The created Propinas record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Propinas record from just the required fields
        propinas = await Propinas.prisma().create(
            data={
                # data to create a Propinas record
                'mes': enums.enum_Propinas_mes.Janeiro,
                'ano_lectivo': 'fcbichhci',
                'createdAt': datetime.datetime.utcnow(),
                'updatedAt': datetime.datetime.utcnow(),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.PropinasCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Propinas records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Propinas record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Propinas.prisma().create_many(
            data=[
                {
                    # data to create a Propinas record
                    'mes': enums.enum_Propinas_mes.Janeiro,
                    'ano_lectivo': 'bcggadccgf',
                    'createdAt': datetime.datetime.utcnow(),
                    'updatedAt': datetime.datetime.utcnow(),
                },
                {
                    # data to create a Propinas record
                    'mes': enums.enum_Propinas_mes.Janeiro,
                    'ano_lectivo': 'jdcfdcgc',
                    'createdAt': datetime.datetime.utcnow(),
                    'updatedAt': datetime.datetime.utcnow(),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.PropinasWhereUniqueInput,
        include: Optional[types.PropinasInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Propinas record.

        Parameters
        ----------
        where
            Propinas filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Propinas model

        Returns
        -------
        prisma.models.Propinas
            The deleted Propinas record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        propinas = await Propinas.prisma().delete(
            where={
                'id': 2053047983,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.PropinasWhereUniqueInput,
        include: Optional[types.PropinasInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Propinas record.

        Parameters
        ----------
        where
            Propinas filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Propinas model

        Returns
        -------
        prisma.models.Propinas
            The found Propinas record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        propinas = await Propinas.prisma().find_unique(
            where={
                'id': 685333180,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.PropinasWhereUniqueInput,
        include: Optional[types.PropinasInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Propinas record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Propinas filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Propinas model

        Returns
        -------
        prisma.models.Propinas
            The found Propinas record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        propinas = await Propinas.prisma().find_unique_or_raise(
            where={
                'id': 127474245,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PropinasWhereInput] = None,
        cursor: Optional[types.PropinasWhereUniqueInput] = None,
        include: Optional[types.PropinasInclude] = None,
        order: Optional[Union[types.PropinasOrderByInput, List[types.PropinasOrderByInput]]] = None,
        distinct: Optional[List[types.PropinasScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Propinas records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Propinas records returned
        skip
            Ignore the first N results
        where
            Propinas filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Propinas model
        order
            Order the returned Propinas records by any field
        distinct
            Filter Propinas records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Propinas]
            The list of all Propinas records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Propinas records
        propinas = await Propinas.prisma().find_many(take=10)

        # find the first 5 Propinas records ordered by the ano_lectivo field
        propinas = await Propinas.prisma().find_many(
            take=5,
            order={
                'ano_lectivo': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PropinasWhereInput] = None,
        cursor: Optional[types.PropinasWhereUniqueInput] = None,
        include: Optional[types.PropinasInclude] = None,
        order: Optional[Union[types.PropinasOrderByInput, List[types.PropinasOrderByInput]]] = None,
        distinct: Optional[List[types.PropinasScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Propinas record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Propinas filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Propinas model
        order
            Order the returned Propinas records by any field
        distinct
            Filter Propinas records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Propinas
            The first Propinas record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Propinas record ordered by the createdAt field
        propinas = await Propinas.prisma().find_first(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PropinasWhereInput] = None,
        cursor: Optional[types.PropinasWhereUniqueInput] = None,
        include: Optional[types.PropinasInclude] = None,
        order: Optional[Union[types.PropinasOrderByInput, List[types.PropinasOrderByInput]]] = None,
        distinct: Optional[List[types.PropinasScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Propinas record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Propinas filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Propinas model
        order
            Order the returned Propinas records by any field
        distinct
            Filter Propinas records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Propinas
            The first Propinas record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Propinas record ordered by the updatedAt field
        propinas = await Propinas.prisma().find_first_or_raise(
            skip=1,
            order={
                'updatedAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.PropinasUpdateInput,
        where: types.PropinasWhereUniqueInput,
        include: Optional[types.PropinasInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Propinas record.

        Parameters
        ----------
        data
            Propinas record data specifying what to update
        where
            Propinas filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Propinas model

        Returns
        -------
        prisma.models.Propinas
            The updated Propinas record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        propinas = await Propinas.prisma().update(
            where={
                'id': 948921754,
            },
            data={
                # data to update the Propinas record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.PropinasWhereUniqueInput,
        data: types.PropinasUpsertInput,
        include: Optional[types.PropinasInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Propinas filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Propinas model

        Returns
        -------
        prisma.models.Propinas
            The created or updated Propinas record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        propinas = await Propinas.prisma().upsert(
            where={
                'id': 1964990155,
            },
            data={
                'create': {
                    'id': 1964990155,
                    'mes': enums.enum_Propinas_mes.Janeiro,
                    'ano_lectivo': 'jdcfdcgc',
                    'createdAt': datetime.datetime.utcnow(),
                    'updatedAt': datetime.datetime.utcnow(),
                },
                'update': {
                    'mes': enums.enum_Propinas_mes.Janeiro,
                    'ano_lectivo': 'jdcfdcgc',
                    'createdAt': datetime.datetime.utcnow(),
                    'updatedAt': datetime.datetime.utcnow(),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.PropinasUpdateManyMutationInput,
        where: types.PropinasWhereInput,
    ) -> int:
        """Update multiple Propinas records

        Parameters
        ----------
        data
            Propinas data to update the selected Propinas records to
        where
            Filter to select the Propinas records to update

        Returns
        -------
        int
            The total number of Propinas records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Propinas records
        total = await Propinas.prisma().update_many(
            data={
                'id': 1228891816
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PropinasWhereInput] = None,
        cursor: Optional[types.PropinasWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Propinas records present in the database

        Parameters
        ----------
        select
            Select the Propinas fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Propinas filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PropinasCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Propinas.prisma().count()

        # results: prisma.types.PropinasCountAggregateOutput
        results = await Propinas.prisma().count(
            select={
                '_all': True,
                'mes': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.PropinasCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PropinasWhereInput] = None,
        cursor: Optional[types.PropinasWhereUniqueInput] = None,
    ) -> types.PropinasCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.PropinasCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PropinasWhereInput] = None,
        cursor: Optional[types.PropinasWhereUniqueInput] = None,
    ) -> Union[int, types.PropinasCountAggregateOutput]:
        """Count the number of Propinas records present in the database

        Parameters
        ----------
        select
            Select the Propinas fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Propinas filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PropinasCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Propinas.prisma().count()

        # results: prisma.types.PropinasCountAggregateOutput
        results = await Propinas.prisma().count(
            select={
                '_all': True,
                'ano_lectivo': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.PropinasCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.PropinasWhereInput] = None
    ) -> int:
        """Delete multiple Propinas records.

        Parameters
        ----------
        where
            Optional Propinas filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Propinas records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Propinas records
        total = await Propinas.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.PropinasScalarFieldKeys'],
        *,
        where: Optional['types.PropinasWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.PropinasAvgAggregateInput'] = None,
        sum: Optional['types.PropinasSumAggregateInput'] = None,
        min: Optional['types.PropinasMinAggregateInput'] = None,
        max: Optional['types.PropinasMaxAggregateInput'] = None,
        having: Optional['types.PropinasScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.PropinasCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.PropinasScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.PropinasScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.PropinasGroupByOutput']:
        """Group Propinas records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Propinas fields to group records by
        where
            Propinas filter to select records
        take
            Limit the maximum number of Propinas records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.PropinasGroupByOutput]
            A list of dictionaries representing the Propinas record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Propinas records by createdAt values
        # and count how many records are in each group
        results = await Propinas.prisma().group_by(
            ['createdAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ReconhecimentoActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Reconhecimento]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Reconhecimento.prisma().query_raw(
            'SELECT * FROM Reconhecimento WHERE id = $1',
            255202753,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Reconhecimento
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Reconhecimento.prisma().query_first(
            'SELECT * FROM Reconhecimento WHERE alunoId = $1',
            1223573862,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ReconhecimentoCreateInput,
        include: Optional[types.ReconhecimentoInclude] = None
    ) -> _PrismaModelT:
        """Create a new Reconhecimento record.

        Parameters
        ----------
        data
            Reconhecimento record data
        include
            Specifies which relations should be loaded on the returned Reconhecimento model

        Returns
        -------
        prisma.models.Reconhecimento
            The created Reconhecimento record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Reconhecimento record from just the required fields
        reconhecimento = await Reconhecimento.prisma().create(
            data={
                # data to create a Reconhecimento record
                'alunoId': 541269159,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ReconhecimentoCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Reconhecimento records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Reconhecimento record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Reconhecimento.prisma().create_many(
            data=[
                {
                    # data to create a Reconhecimento record
                    'alunoId': 1064846676,
                },
                {
                    # data to create a Reconhecimento record
                    'alunoId': 508382461,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ReconhecimentoWhereUniqueInput,
        include: Optional[types.ReconhecimentoInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Reconhecimento record.

        Parameters
        ----------
        where
            Reconhecimento filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Reconhecimento model

        Returns
        -------
        prisma.models.Reconhecimento
            The deleted Reconhecimento record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        reconhecimento = await Reconhecimento.prisma().delete(
            where={
                'id': 1024265714,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ReconhecimentoWhereUniqueInput,
        include: Optional[types.ReconhecimentoInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Reconhecimento record.

        Parameters
        ----------
        where
            Reconhecimento filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Reconhecimento model

        Returns
        -------
        prisma.models.Reconhecimento
            The found Reconhecimento record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        reconhecimento = await Reconhecimento.prisma().find_unique(
            where={
                'id': 872078403,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ReconhecimentoWhereUniqueInput,
        include: Optional[types.ReconhecimentoInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Reconhecimento record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Reconhecimento filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Reconhecimento model

        Returns
        -------
        prisma.models.Reconhecimento
            The found Reconhecimento record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        reconhecimento = await Reconhecimento.prisma().find_unique_or_raise(
            where={
                'id': 1874748096,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ReconhecimentoWhereInput] = None,
        cursor: Optional[types.ReconhecimentoWhereUniqueInput] = None,
        include: Optional[types.ReconhecimentoInclude] = None,
        order: Optional[Union[types.ReconhecimentoOrderByInput, List[types.ReconhecimentoOrderByInput]]] = None,
        distinct: Optional[List[types.ReconhecimentoScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Reconhecimento records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Reconhecimento records returned
        skip
            Ignore the first N results
        where
            Reconhecimento filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Reconhecimento model
        order
            Order the returned Reconhecimento records by any field
        distinct
            Filter Reconhecimento records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Reconhecimento]
            The list of all Reconhecimento records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Reconhecimento records
        reconhecimentos = await Reconhecimento.prisma().find_many(take=10)

        # find the first 5 Reconhecimento records ordered by the createdAt field
        reconhecimentos = await Reconhecimento.prisma().find_many(
            take=5,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ReconhecimentoWhereInput] = None,
        cursor: Optional[types.ReconhecimentoWhereUniqueInput] = None,
        include: Optional[types.ReconhecimentoInclude] = None,
        order: Optional[Union[types.ReconhecimentoOrderByInput, List[types.ReconhecimentoOrderByInput]]] = None,
        distinct: Optional[List[types.ReconhecimentoScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Reconhecimento record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Reconhecimento filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Reconhecimento model
        order
            Order the returned Reconhecimento records by any field
        distinct
            Filter Reconhecimento records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Reconhecimento
            The first Reconhecimento record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Reconhecimento record ordered by the updatedAt field
        reconhecimento = await Reconhecimento.prisma().find_first(
            skip=1,
            order={
                'updatedAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ReconhecimentoWhereInput] = None,
        cursor: Optional[types.ReconhecimentoWhereUniqueInput] = None,
        include: Optional[types.ReconhecimentoInclude] = None,
        order: Optional[Union[types.ReconhecimentoOrderByInput, List[types.ReconhecimentoOrderByInput]]] = None,
        distinct: Optional[List[types.ReconhecimentoScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Reconhecimento record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Reconhecimento filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Reconhecimento model
        order
            Order the returned Reconhecimento records by any field
        distinct
            Filter Reconhecimento records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Reconhecimento
            The first Reconhecimento record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Reconhecimento record ordered by the id field
        reconhecimento = await Reconhecimento.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ReconhecimentoUpdateInput,
        where: types.ReconhecimentoWhereUniqueInput,
        include: Optional[types.ReconhecimentoInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Reconhecimento record.

        Parameters
        ----------
        data
            Reconhecimento record data specifying what to update
        where
            Reconhecimento filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Reconhecimento model

        Returns
        -------
        prisma.models.Reconhecimento
            The updated Reconhecimento record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        reconhecimento = await Reconhecimento.prisma().update(
            where={
                'id': 916896761,
            },
            data={
                # data to update the Reconhecimento record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ReconhecimentoWhereUniqueInput,
        data: types.ReconhecimentoUpsertInput,
        include: Optional[types.ReconhecimentoInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Reconhecimento filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Reconhecimento model

        Returns
        -------
        prisma.models.Reconhecimento
            The created or updated Reconhecimento record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        reconhecimento = await Reconhecimento.prisma().upsert(
            where={
                'id': 769267518,
            },
            data={
                'create': {
                    'id': 769267518,
                    'alunoId': 508382461,
                },
                'update': {
                    'alunoId': 508382461,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ReconhecimentoUpdateManyMutationInput,
        where: types.ReconhecimentoWhereInput,
    ) -> int:
        """Update multiple Reconhecimento records

        Parameters
        ----------
        data
            Reconhecimento data to update the selected Reconhecimento records to
        where
            Filter to select the Reconhecimento records to update

        Returns
        -------
        int
            The total number of Reconhecimento records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Reconhecimento records
        total = await Reconhecimento.prisma().update_many(
            data={
                'alunoId': 820312479
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ReconhecimentoWhereInput] = None,
        cursor: Optional[types.ReconhecimentoWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Reconhecimento records present in the database

        Parameters
        ----------
        select
            Select the Reconhecimento fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Reconhecimento filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ReconhecimentoCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Reconhecimento.prisma().count()

        # results: prisma.types.ReconhecimentoCountAggregateOutput
        results = await Reconhecimento.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ReconhecimentoCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ReconhecimentoWhereInput] = None,
        cursor: Optional[types.ReconhecimentoWhereUniqueInput] = None,
    ) -> types.ReconhecimentoCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ReconhecimentoCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ReconhecimentoWhereInput] = None,
        cursor: Optional[types.ReconhecimentoWhereUniqueInput] = None,
    ) -> Union[int, types.ReconhecimentoCountAggregateOutput]:
        """Count the number of Reconhecimento records present in the database

        Parameters
        ----------
        select
            Select the Reconhecimento fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Reconhecimento filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ReconhecimentoCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Reconhecimento.prisma().count()

        # results: prisma.types.ReconhecimentoCountAggregateOutput
        results = await Reconhecimento.prisma().count(
            select={
                '_all': True,
                'updatedAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ReconhecimentoCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ReconhecimentoWhereInput] = None
    ) -> int:
        """Delete multiple Reconhecimento records.

        Parameters
        ----------
        where
            Optional Reconhecimento filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Reconhecimento records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Reconhecimento records
        total = await Reconhecimento.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ReconhecimentoScalarFieldKeys'],
        *,
        where: Optional['types.ReconhecimentoWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ReconhecimentoAvgAggregateInput'] = None,
        sum: Optional['types.ReconhecimentoSumAggregateInput'] = None,
        min: Optional['types.ReconhecimentoMinAggregateInput'] = None,
        max: Optional['types.ReconhecimentoMaxAggregateInput'] = None,
        having: Optional['types.ReconhecimentoScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ReconhecimentoCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ReconhecimentoScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.ReconhecimentoScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.ReconhecimentoGroupByOutput']:
        """Group Reconhecimento records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Reconhecimento fields to group records by
        where
            Reconhecimento filter to select records
        take
            Limit the maximum number of Reconhecimento records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ReconhecimentoGroupByOutput]
            A list of dictionaries representing the Reconhecimento record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Reconhecimento records by id values
        # and count how many records are in each group
        results = await Reconhecimento.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class SequelizeMetaActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.SequelizeMeta]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await SequelizeMeta.prisma().query_raw(
            'SELECT * FROM SequelizeMeta WHERE name = $1',
            'jchciaee',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.SequelizeMeta
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await SequelizeMeta.prisma().query_first(
            'SELECT * FROM SequelizeMeta WHERE name = $1',
            'deeificjd',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.SequelizeMetaCreateInput,
        include: Optional[types.SequelizeMetaInclude] = None
    ) -> _PrismaModelT:
        """Create a new SequelizeMeta record.

        Parameters
        ----------
        data
            SequelizeMeta record data
        include
            Specifies which relations should be loaded on the returned SequelizeMeta model

        Returns
        -------
        prisma.models.SequelizeMeta
            The created SequelizeMeta record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a SequelizeMeta record from just the required fields
        sequelizemeta = await SequelizeMeta.prisma().create(
            data={
                # data to create a SequelizeMeta record
                'name': 'bbcbhebbda',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.SequelizeMetaCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple SequelizeMeta records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of SequelizeMeta record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await SequelizeMeta.prisma().create_many(
            data=[
                {
                    # data to create a SequelizeMeta record
                    'name': 'bejfijgcfb',
                },
                {
                    # data to create a SequelizeMeta record
                    'name': 'caifcbgii',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.SequelizeMetaWhereUniqueInput,
        include: Optional[types.SequelizeMetaInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single SequelizeMeta record.

        Parameters
        ----------
        where
            SequelizeMeta filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned SequelizeMeta model

        Returns
        -------
        prisma.models.SequelizeMeta
            The deleted SequelizeMeta record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        sequelizemeta = await SequelizeMeta.prisma().delete(
            where={
                'name': 'igaibbfgj',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.SequelizeMetaWhereUniqueInput,
        include: Optional[types.SequelizeMetaInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique SequelizeMeta record.

        Parameters
        ----------
        where
            SequelizeMeta filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned SequelizeMeta model

        Returns
        -------
        prisma.models.SequelizeMeta
            The found SequelizeMeta record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        sequelizemeta = await SequelizeMeta.prisma().find_unique(
            where={
                'name': 'bggajdcbbi',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.SequelizeMetaWhereUniqueInput,
        include: Optional[types.SequelizeMetaInclude] = None
    ) -> _PrismaModelT:
        """Find a unique SequelizeMeta record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            SequelizeMeta filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned SequelizeMeta model

        Returns
        -------
        prisma.models.SequelizeMeta
            The found SequelizeMeta record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        sequelizemeta = await SequelizeMeta.prisma().find_unique_or_raise(
            where={
                'name': 'fcfhgbjed',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SequelizeMetaWhereInput] = None,
        cursor: Optional[types.SequelizeMetaWhereUniqueInput] = None,
        include: Optional[types.SequelizeMetaInclude] = None,
        order: Optional[Union[types.SequelizeMetaOrderByInput, List[types.SequelizeMetaOrderByInput]]] = None,
        distinct: Optional[List[types.SequelizeMetaScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple SequelizeMeta records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of SequelizeMeta records returned
        skip
            Ignore the first N results
        where
            SequelizeMeta filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned SequelizeMeta model
        order
            Order the returned SequelizeMeta records by any field
        distinct
            Filter SequelizeMeta records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.SequelizeMeta]
            The list of all SequelizeMeta records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 SequelizeMeta records
        sequelizemetas = await SequelizeMeta.prisma().find_many(take=10)

        # find the first 5 SequelizeMeta records ordered by the name field
        sequelizemetas = await SequelizeMeta.prisma().find_many(
            take=5,
            order={
                'name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.SequelizeMetaWhereInput] = None,
        cursor: Optional[types.SequelizeMetaWhereUniqueInput] = None,
        include: Optional[types.SequelizeMetaInclude] = None,
        order: Optional[Union[types.SequelizeMetaOrderByInput, List[types.SequelizeMetaOrderByInput]]] = None,
        distinct: Optional[List[types.SequelizeMetaScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single SequelizeMeta record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            SequelizeMeta filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned SequelizeMeta model
        order
            Order the returned SequelizeMeta records by any field
        distinct
            Filter SequelizeMeta records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.SequelizeMeta
            The first SequelizeMeta record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second SequelizeMeta record ordered by the name field
        sequelizemeta = await SequelizeMeta.prisma().find_first(
            skip=1,
            order={
                'name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.SequelizeMetaWhereInput] = None,
        cursor: Optional[types.SequelizeMetaWhereUniqueInput] = None,
        include: Optional[types.SequelizeMetaInclude] = None,
        order: Optional[Union[types.SequelizeMetaOrderByInput, List[types.SequelizeMetaOrderByInput]]] = None,
        distinct: Optional[List[types.SequelizeMetaScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single SequelizeMeta record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            SequelizeMeta filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned SequelizeMeta model
        order
            Order the returned SequelizeMeta records by any field
        distinct
            Filter SequelizeMeta records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.SequelizeMeta
            The first SequelizeMeta record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second SequelizeMeta record ordered by the name field
        sequelizemeta = await SequelizeMeta.prisma().find_first_or_raise(
            skip=1,
            order={
                'name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.SequelizeMetaUpdateInput,
        where: types.SequelizeMetaWhereUniqueInput,
        include: Optional[types.SequelizeMetaInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single SequelizeMeta record.

        Parameters
        ----------
        data
            SequelizeMeta record data specifying what to update
        where
            SequelizeMeta filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned SequelizeMeta model

        Returns
        -------
        prisma.models.SequelizeMeta
            The updated SequelizeMeta record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        sequelizemeta = await SequelizeMeta.prisma().update(
            where={
                'name': 'hdgcajhjg',
            },
            data={
                # data to update the SequelizeMeta record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.SequelizeMetaWhereUniqueInput,
        data: types.SequelizeMetaUpsertInput,
        include: Optional[types.SequelizeMetaInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            SequelizeMeta filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned SequelizeMeta model

        Returns
        -------
        prisma.models.SequelizeMeta
            The created or updated SequelizeMeta record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        sequelizemeta = await SequelizeMeta.prisma().upsert(
            where={
                'name': 'ejdjahicb',
            },
            data={
                'create': {
                    'name': 'ejdjahicb',
                },
                'update': {
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.SequelizeMetaUpdateManyMutationInput,
        where: types.SequelizeMetaWhereInput,
    ) -> int:
        """Update multiple SequelizeMeta records

        Parameters
        ----------
        data
            SequelizeMeta data to update the selected SequelizeMeta records to
        where
            Filter to select the SequelizeMeta records to update

        Returns
        -------
        int
            The total number of SequelizeMeta records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all SequelizeMeta records
        total = await SequelizeMeta.prisma().update_many(
            data={
                'name': 'gdjgigfgc'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SequelizeMetaWhereInput] = None,
        cursor: Optional[types.SequelizeMetaWhereUniqueInput] = None,
    ) -> int:
        """Count the number of SequelizeMeta records present in the database

        Parameters
        ----------
        select
            Select the SequelizeMeta fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            SequelizeMeta filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SequelizeMetaCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await SequelizeMeta.prisma().count()

        # results: prisma.types.SequelizeMetaCountAggregateOutput
        results = await SequelizeMeta.prisma().count(
            select={
                '_all': True,
                'name': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.SequelizeMetaCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SequelizeMetaWhereInput] = None,
        cursor: Optional[types.SequelizeMetaWhereUniqueInput] = None,
    ) -> types.SequelizeMetaCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.SequelizeMetaCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SequelizeMetaWhereInput] = None,
        cursor: Optional[types.SequelizeMetaWhereUniqueInput] = None,
    ) -> Union[int, types.SequelizeMetaCountAggregateOutput]:
        """Count the number of SequelizeMeta records present in the database

        Parameters
        ----------
        select
            Select the SequelizeMeta fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            SequelizeMeta filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SequelizeMetaCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await SequelizeMeta.prisma().count()

        # results: prisma.types.SequelizeMetaCountAggregateOutput
        results = await SequelizeMeta.prisma().count(
            select={
                '_all': True,
                'name': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.SequelizeMetaCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.SequelizeMetaWhereInput] = None
    ) -> int:
        """Delete multiple SequelizeMeta records.

        Parameters
        ----------
        where
            Optional SequelizeMeta filter to find the records to be deleted

        Returns
        -------
        int
            The total number of SequelizeMeta records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all SequelizeMeta records
        total = await SequelizeMeta.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.SequelizeMetaScalarFieldKeys'],
        *,
        where: Optional['types.SequelizeMetaWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.SequelizeMetaAvgAggregateInput'] = None,
        sum: Optional['types.SequelizeMetaSumAggregateInput'] = None,
        min: Optional['types.SequelizeMetaMinAggregateInput'] = None,
        max: Optional['types.SequelizeMetaMaxAggregateInput'] = None,
        having: Optional['types.SequelizeMetaScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.SequelizeMetaCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.SequelizeMetaScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.SequelizeMetaScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.SequelizeMetaGroupByOutput']:
        """Group SequelizeMeta records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar SequelizeMeta fields to group records by
        where
            SequelizeMeta filter to select records
        take
            Limit the maximum number of SequelizeMeta records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.SequelizeMetaGroupByOutput]
            A list of dictionaries representing the SequelizeMeta record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group SequelizeMeta records by name values
        # and count how many records are in each group
        results = await SequelizeMeta.prisma().group_by(
            ['name'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class UsersActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Users]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Users.prisma().query_raw(
            'SELECT * FROM Users WHERE id = $1',
            654007347,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Users
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Users.prisma().query_first(
            'SELECT * FROM Users WHERE nome_completo = $1',
            'bjafcgbffc',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.UsersCreateInput,
        include: Optional[types.UsersInclude] = None
    ) -> _PrismaModelT:
        """Create a new Users record.

        Parameters
        ----------
        data
            Users record data
        include
            Specifies which relations should be loaded on the returned Users model

        Returns
        -------
        prisma.models.Users
            The created Users record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Users record from just the required fields
        users = await Users.prisma().create(
            data={
                # data to create a Users record
                'createdAt': datetime.datetime.utcnow(),
                'updatedAt': datetime.datetime.utcnow(),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.UsersCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Users records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Users record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Users.prisma().create_many(
            data=[
                {
                    # data to create a Users record
                    'createdAt': datetime.datetime.utcnow(),
                    'updatedAt': datetime.datetime.utcnow(),
                },
                {
                    # data to create a Users record
                    'createdAt': datetime.datetime.utcnow(),
                    'updatedAt': datetime.datetime.utcnow(),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.UsersWhereUniqueInput,
        include: Optional[types.UsersInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Users record.

        Parameters
        ----------
        where
            Users filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Users model

        Returns
        -------
        prisma.models.Users
            The deleted Users record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        users = await Users.prisma().delete(
            where={
                'id': 78746985,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.UsersWhereUniqueInput,
        include: Optional[types.UsersInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Users record.

        Parameters
        ----------
        where
            Users filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Users model

        Returns
        -------
        prisma.models.Users
            The found Users record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        users = await Users.prisma().find_unique(
            where={
                'id': 1398328302,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.UsersWhereUniqueInput,
        include: Optional[types.UsersInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Users record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Users filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Users model

        Returns
        -------
        prisma.models.Users
            The found Users record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        users = await Users.prisma().find_unique_or_raise(
            where={
                'id': 856000655,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UsersWhereInput] = None,
        cursor: Optional[types.UsersWhereUniqueInput] = None,
        include: Optional[types.UsersInclude] = None,
        order: Optional[Union[types.UsersOrderByInput, List[types.UsersOrderByInput]]] = None,
        distinct: Optional[List[types.UsersScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Users records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Users records returned
        skip
            Ignore the first N results
        where
            Users filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Users model
        order
            Order the returned Users records by any field
        distinct
            Filter Users records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Users]
            The list of all Users records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Users records
        users = await Users.prisma().find_many(take=10)

        # find the first 5 Users records ordered by the email field
        users = await Users.prisma().find_many(
            take=5,
            order={
                'email': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UsersWhereInput] = None,
        cursor: Optional[types.UsersWhereUniqueInput] = None,
        include: Optional[types.UsersInclude] = None,
        order: Optional[Union[types.UsersOrderByInput, List[types.UsersOrderByInput]]] = None,
        distinct: Optional[List[types.UsersScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Users record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Users filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Users model
        order
            Order the returned Users records by any field
        distinct
            Filter Users records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Users
            The first Users record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Users record ordered by the pin_acesso field
        users = await Users.prisma().find_first(
            skip=1,
            order={
                'pin_acesso': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UsersWhereInput] = None,
        cursor: Optional[types.UsersWhereUniqueInput] = None,
        include: Optional[types.UsersInclude] = None,
        order: Optional[Union[types.UsersOrderByInput, List[types.UsersOrderByInput]]] = None,
        distinct: Optional[List[types.UsersScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Users record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Users filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Users model
        order
            Order the returned Users records by any field
        distinct
            Filter Users records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Users
            The first Users record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Users record ordered by the telefone field
        users = await Users.prisma().find_first_or_raise(
            skip=1,
            order={
                'telefone': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.UsersUpdateInput,
        where: types.UsersWhereUniqueInput,
        include: Optional[types.UsersInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Users record.

        Parameters
        ----------
        data
            Users record data specifying what to update
        where
            Users filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Users model

        Returns
        -------
        prisma.models.Users
            The updated Users record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Users.prisma().update(
            where={
                'id': 1452336924,
            },
            data={
                # data to update the Users record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.UsersWhereUniqueInput,
        data: types.UsersUpsertInput,
        include: Optional[types.UsersInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Users filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Users model

        Returns
        -------
        prisma.models.Users
            The created or updated Users record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        users = await Users.prisma().upsert(
            where={
                'id': 1573199653,
            },
            data={
                'create': {
                    'id': 1573199653,
                    'createdAt': datetime.datetime.utcnow(),
                    'updatedAt': datetime.datetime.utcnow(),
                },
                'update': {
                    'createdAt': datetime.datetime.utcnow(),
                    'updatedAt': datetime.datetime.utcnow(),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.UsersUpdateManyMutationInput,
        where: types.UsersWhereInput,
    ) -> int:
        """Update multiple Users records

        Parameters
        ----------
        data
            Users data to update the selected Users records to
        where
            Filter to select the Users records to update

        Returns
        -------
        int
            The total number of Users records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Users records
        total = await Users.prisma().update_many(
            data={
                'type': enums.enum_Users_type.admin
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UsersWhereInput] = None,
        cursor: Optional[types.UsersWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Users records present in the database

        Parameters
        ----------
        select
            Select the Users fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Users filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UsersCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Users.prisma().count()

        # results: prisma.types.UsersCountAggregateOutput
        results = await Users.prisma().count(
            select={
                '_all': True,
                'bi': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.UsersCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UsersWhereInput] = None,
        cursor: Optional[types.UsersWhereUniqueInput] = None,
    ) -> types.UsersCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.UsersCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UsersWhereInput] = None,
        cursor: Optional[types.UsersWhereUniqueInput] = None,
    ) -> Union[int, types.UsersCountAggregateOutput]:
        """Count the number of Users records present in the database

        Parameters
        ----------
        select
            Select the Users fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Users filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UsersCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Users.prisma().count()

        # results: prisma.types.UsersCountAggregateOutput
        results = await Users.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.UsersCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.UsersWhereInput] = None
    ) -> int:
        """Delete multiple Users records.

        Parameters
        ----------
        where
            Optional Users filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Users records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Users records
        total = await Users.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.UsersScalarFieldKeys'],
        *,
        where: Optional['types.UsersWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.UsersAvgAggregateInput'] = None,
        sum: Optional['types.UsersSumAggregateInput'] = None,
        min: Optional['types.UsersMinAggregateInput'] = None,
        max: Optional['types.UsersMaxAggregateInput'] = None,
        having: Optional['types.UsersScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.UsersCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.UsersScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.UsersScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.UsersGroupByOutput']:
        """Group Users records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Users fields to group records by
        where
            Users filter to select records
        take
            Limit the maximum number of Users records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.UsersGroupByOutput]
            A list of dictionaries representing the Users record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Users records by updatedAt values
        # and count how many records are in each group
        results = await Users.prisma().group_by(
            ['updatedAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class VigilantesActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Vigilantes]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Vigilantes.prisma().query_raw(
            'SELECT * FROM Vigilantes WHERE id = $1',
            2013903098,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Vigilantes
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Vigilantes.prisma().query_first(
            'SELECT * FROM Vigilantes WHERE turno = $1',
            enums.enum_Vigilantes_turno.m,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.VigilantesCreateInput,
        include: Optional[types.VigilantesInclude] = None
    ) -> _PrismaModelT:
        """Create a new Vigilantes record.

        Parameters
        ----------
        data
            Vigilantes record data
        include
            Specifies which relations should be loaded on the returned Vigilantes model

        Returns
        -------
        prisma.models.Vigilantes
            The created Vigilantes record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Vigilantes record from just the required fields
        vigilantes = await Vigilantes.prisma().create(
            data={
                # data to create a Vigilantes record
                'turno': enums.enum_Vigilantes_turno.m,
                'createdAt': datetime.datetime.utcnow(),
                'updatedAt': datetime.datetime.utcnow(),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.VigilantesCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Vigilantes records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Vigilantes record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Vigilantes.prisma().create_many(
            data=[
                {
                    # data to create a Vigilantes record
                    'turno': enums.enum_Vigilantes_turno.m,
                    'createdAt': datetime.datetime.utcnow(),
                    'updatedAt': datetime.datetime.utcnow(),
                },
                {
                    # data to create a Vigilantes record
                    'turno': enums.enum_Vigilantes_turno.m,
                    'createdAt': datetime.datetime.utcnow(),
                    'updatedAt': datetime.datetime.utcnow(),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.VigilantesWhereUniqueInput,
        include: Optional[types.VigilantesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Vigilantes record.

        Parameters
        ----------
        where
            Vigilantes filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Vigilantes model

        Returns
        -------
        prisma.models.Vigilantes
            The deleted Vigilantes record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        vigilantes = await Vigilantes.prisma().delete(
            where={
                'id': 500965035,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.VigilantesWhereUniqueInput,
        include: Optional[types.VigilantesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Vigilantes record.

        Parameters
        ----------
        where
            Vigilantes filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Vigilantes model

        Returns
        -------
        prisma.models.Vigilantes
            The found Vigilantes record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        vigilantes = await Vigilantes.prisma().find_unique(
            where={
                'id': 1800624392,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.VigilantesWhereUniqueInput,
        include: Optional[types.VigilantesInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Vigilantes record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Vigilantes filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Vigilantes model

        Returns
        -------
        prisma.models.Vigilantes
            The found Vigilantes record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        vigilantes = await Vigilantes.prisma().find_unique_or_raise(
            where={
                'id': 2077067425,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.VigilantesWhereInput] = None,
        cursor: Optional[types.VigilantesWhereUniqueInput] = None,
        include: Optional[types.VigilantesInclude] = None,
        order: Optional[Union[types.VigilantesOrderByInput, List[types.VigilantesOrderByInput]]] = None,
        distinct: Optional[List[types.VigilantesScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Vigilantes records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Vigilantes records returned
        skip
            Ignore the first N results
        where
            Vigilantes filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Vigilantes model
        order
            Order the returned Vigilantes records by any field
        distinct
            Filter Vigilantes records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Vigilantes]
            The list of all Vigilantes records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Vigilantes records
        vigilantes = await Vigilantes.prisma().find_many(take=10)

        # find the first 5 Vigilantes records ordered by the descricao field
        vigilantes = await Vigilantes.prisma().find_many(
            take=5,
            order={
                'descricao': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.VigilantesWhereInput] = None,
        cursor: Optional[types.VigilantesWhereUniqueInput] = None,
        include: Optional[types.VigilantesInclude] = None,
        order: Optional[Union[types.VigilantesOrderByInput, List[types.VigilantesOrderByInput]]] = None,
        distinct: Optional[List[types.VigilantesScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Vigilantes record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Vigilantes filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Vigilantes model
        order
            Order the returned Vigilantes records by any field
        distinct
            Filter Vigilantes records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Vigilantes
            The first Vigilantes record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Vigilantes record ordered by the UserId field
        vigilantes = await Vigilantes.prisma().find_first(
            skip=1,
            order={
                'UserId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.VigilantesWhereInput] = None,
        cursor: Optional[types.VigilantesWhereUniqueInput] = None,
        include: Optional[types.VigilantesInclude] = None,
        order: Optional[Union[types.VigilantesOrderByInput, List[types.VigilantesOrderByInput]]] = None,
        distinct: Optional[List[types.VigilantesScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Vigilantes record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Vigilantes filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Vigilantes model
        order
            Order the returned Vigilantes records by any field
        distinct
            Filter Vigilantes records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Vigilantes
            The first Vigilantes record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Vigilantes record ordered by the createdAt field
        vigilantes = await Vigilantes.prisma().find_first_or_raise(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.VigilantesUpdateInput,
        where: types.VigilantesWhereUniqueInput,
        include: Optional[types.VigilantesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Vigilantes record.

        Parameters
        ----------
        data
            Vigilantes record data specifying what to update
        where
            Vigilantes filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Vigilantes model

        Returns
        -------
        prisma.models.Vigilantes
            The updated Vigilantes record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        vigilantes = await Vigilantes.prisma().update(
            where={
                'id': 1672112838,
            },
            data={
                # data to update the Vigilantes record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.VigilantesWhereUniqueInput,
        data: types.VigilantesUpsertInput,
        include: Optional[types.VigilantesInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Vigilantes filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Vigilantes model

        Returns
        -------
        prisma.models.Vigilantes
            The created or updated Vigilantes record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        vigilantes = await Vigilantes.prisma().upsert(
            where={
                'id': 926677639,
            },
            data={
                'create': {
                    'id': 926677639,
                    'turno': enums.enum_Vigilantes_turno.m,
                    'createdAt': datetime.datetime.utcnow(),
                    'updatedAt': datetime.datetime.utcnow(),
                },
                'update': {
                    'turno': enums.enum_Vigilantes_turno.m,
                    'createdAt': datetime.datetime.utcnow(),
                    'updatedAt': datetime.datetime.utcnow(),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.VigilantesUpdateManyMutationInput,
        where: types.VigilantesWhereInput,
    ) -> int:
        """Update multiple Vigilantes records

        Parameters
        ----------
        data
            Vigilantes data to update the selected Vigilantes records to
        where
            Filter to select the Vigilantes records to update

        Returns
        -------
        int
            The total number of Vigilantes records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Vigilantes records
        total = await Vigilantes.prisma().update_many(
            data={
                'updatedAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.VigilantesWhereInput] = None,
        cursor: Optional[types.VigilantesWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Vigilantes records present in the database

        Parameters
        ----------
        select
            Select the Vigilantes fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Vigilantes filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.VigilantesCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Vigilantes.prisma().count()

        # results: prisma.types.VigilantesCountAggregateOutput
        results = await Vigilantes.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.VigilantesCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.VigilantesWhereInput] = None,
        cursor: Optional[types.VigilantesWhereUniqueInput] = None,
    ) -> types.VigilantesCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.VigilantesCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.VigilantesWhereInput] = None,
        cursor: Optional[types.VigilantesWhereUniqueInput] = None,
    ) -> Union[int, types.VigilantesCountAggregateOutput]:
        """Count the number of Vigilantes records present in the database

        Parameters
        ----------
        select
            Select the Vigilantes fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Vigilantes filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.VigilantesCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Vigilantes.prisma().count()

        # results: prisma.types.VigilantesCountAggregateOutput
        results = await Vigilantes.prisma().count(
            select={
                '_all': True,
                'turno': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.VigilantesCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.VigilantesWhereInput] = None
    ) -> int:
        """Delete multiple Vigilantes records.

        Parameters
        ----------
        where
            Optional Vigilantes filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Vigilantes records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Vigilantes records
        total = await Vigilantes.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.VigilantesScalarFieldKeys'],
        *,
        where: Optional['types.VigilantesWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.VigilantesAvgAggregateInput'] = None,
        sum: Optional['types.VigilantesSumAggregateInput'] = None,
        min: Optional['types.VigilantesMinAggregateInput'] = None,
        max: Optional['types.VigilantesMaxAggregateInput'] = None,
        having: Optional['types.VigilantesScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.VigilantesCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.VigilantesScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.VigilantesScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.VigilantesGroupByOutput']:
        """Group Vigilantes records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Vigilantes fields to group records by
        where
            Vigilantes filter to select records
        take
            Limit the maximum number of Vigilantes records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.VigilantesGroupByOutput]
            A list of dictionaries representing the Vigilantes record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Vigilantes records by descricao values
        # and count how many records are in each group
        results = await Vigilantes.prisma().group_by(
            ['descricao'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]



def _select_fields(root: str, select: Mapping[str, Any]) -> str:
    """Helper to build a GraphQL selection string

    This is a work around until field selection is added to the query builder.
    """

    return root + ' {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))


from . import models