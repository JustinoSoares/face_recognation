# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template models.py.jinja --
import os
import logging
import inspect
import warnings
from collections import OrderedDict

from pydantic import BaseModel, Field

from . import types, enums, errors, fields, bases
from ._types import FuncType
from ._compat import model_rebuild, field_validator
from ._builder import serialize_base64
from .generator import partial_models_ctx, PartialModelField


log: logging.Logger = logging.getLogger(__name__)
_created_partial_types: Set[str] = set()

class Alunos(bases.BaseAlunos):
    """Represents a Alunos record"""

    id: _int
    n_do_processo: _int
    nome_completo: _str
    classe: _str
    turno: 'enums.enum_Alunos_turno'
    ano_letivo: _str
    turma: _str
    curso: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    Alunos_propina: Optional[List['models.Alunos_propina']] = None
    Fotos: Optional[List['models.Fotos']] = None
    Historico: Optional[List['models.Historico']] = None
    Reconhecimento: Optional[List['models.Reconhecimento']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.AlunosKeys']] = None,
        exclude: Optional[Iterable['types.AlunosKeys']] = None,
        required: Optional[Iterable['types.AlunosKeys']] = None,
        optional: Optional[Iterable['types.AlunosKeys']] = None,
        relations: Optional[Mapping['types.AlunosRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.AlunosKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Alunos_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Alunos_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Alunos_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Alunos_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Alunos_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Alunos_relational_fields:
                        raise errors.UnknownRelationalFieldError('Alunos', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Alunos / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Alunos',
            }
        )
        _created_partial_types.add(name)


class Alunos_propina(bases.BaseAlunos_propina):
    """Represents a Alunos_propina record"""

    id: _int
    alunoId: Optional[_int] = None
    propinaId: Optional[_int] = None
    valor: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    Alunos: Optional['models.Alunos'] = None
    Propinas: Optional['models.Propinas'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.Alunos_propinaKeys']] = None,
        exclude: Optional[Iterable['types.Alunos_propinaKeys']] = None,
        required: Optional[Iterable['types.Alunos_propinaKeys']] = None,
        optional: Optional[Iterable['types.Alunos_propinaKeys']] = None,
        relations: Optional[Mapping['types.Alunos_propinaRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.Alunos_propinaKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Alunos_propina_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Alunos_propina_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Alunos_propina_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Alunos_propina_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Alunos_propina_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Alunos_propina_relational_fields:
                        raise errors.UnknownRelationalFieldError('Alunos_propina', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Alunos_propina / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Alunos_propina',
            }
        )
        _created_partial_types.add(name)


class Fotos(bases.BaseFotos):
    """Represents a Fotos record"""

    id: _int
    descricao: Optional[_str] = None
    url: _str
    alunoId: Optional[_int] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    Alunos: Optional['models.Alunos'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.FotosKeys']] = None,
        exclude: Optional[Iterable['types.FotosKeys']] = None,
        required: Optional[Iterable['types.FotosKeys']] = None,
        optional: Optional[Iterable['types.FotosKeys']] = None,
        relations: Optional[Mapping['types.FotosRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.FotosKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Fotos_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Fotos_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Fotos_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Fotos_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Fotos_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Fotos_relational_fields:
                        raise errors.UnknownRelationalFieldError('Fotos', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Fotos / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Fotos',
            }
        )
        _created_partial_types.add(name)


class Historico(bases.BaseHistorico):
    """Represents a Historico record"""

    id: _int
    alunoId: Optional[_int] = None
    propinaId: Optional[_int] = None
    status: 'enums.enum_Historico_status'
    timestamp: datetime.datetime
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    Alunos: Optional['models.Alunos'] = None
    Propinas: Optional['models.Propinas'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.HistoricoKeys']] = None,
        exclude: Optional[Iterable['types.HistoricoKeys']] = None,
        required: Optional[Iterable['types.HistoricoKeys']] = None,
        optional: Optional[Iterable['types.HistoricoKeys']] = None,
        relations: Optional[Mapping['types.HistoricoRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.HistoricoKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Historico_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Historico_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Historico_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Historico_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Historico_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Historico_relational_fields:
                        raise errors.UnknownRelationalFieldError('Historico', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Historico / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Historico',
            }
        )
        _created_partial_types.add(name)


class Propinas(bases.BasePropinas):
    """Represents a Propinas record"""

    id: _int
    mes: 'enums.enum_Propinas_mes'
    ano_lectivo: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    Alunos_propina: Optional[List['models.Alunos_propina']] = None
    Historico: Optional[List['models.Historico']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.PropinasKeys']] = None,
        exclude: Optional[Iterable['types.PropinasKeys']] = None,
        required: Optional[Iterable['types.PropinasKeys']] = None,
        optional: Optional[Iterable['types.PropinasKeys']] = None,
        relations: Optional[Mapping['types.PropinasRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.PropinasKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Propinas_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Propinas_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Propinas_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Propinas_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Propinas_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Propinas_relational_fields:
                        raise errors.UnknownRelationalFieldError('Propinas', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Propinas / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Propinas',
            }
        )
        _created_partial_types.add(name)


class Reconhecimento(bases.BaseReconhecimento):
    """Represents a Reconhecimento record"""

    id: _int
    alunoId: _int
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    Alunos: Optional['models.Alunos'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.ReconhecimentoKeys']] = None,
        exclude: Optional[Iterable['types.ReconhecimentoKeys']] = None,
        required: Optional[Iterable['types.ReconhecimentoKeys']] = None,
        optional: Optional[Iterable['types.ReconhecimentoKeys']] = None,
        relations: Optional[Mapping['types.ReconhecimentoRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.ReconhecimentoKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Reconhecimento_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Reconhecimento_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Reconhecimento_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Reconhecimento_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Reconhecimento_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Reconhecimento_relational_fields:
                        raise errors.UnknownRelationalFieldError('Reconhecimento', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Reconhecimento / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Reconhecimento',
            }
        )
        _created_partial_types.add(name)


class SequelizeMeta(bases.BaseSequelizeMeta):
    """Represents a SequelizeMeta record"""

    name: _str

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.SequelizeMetaKeys']] = None,
        exclude: Optional[Iterable['types.SequelizeMetaKeys']] = None,
        required: Optional[Iterable['types.SequelizeMetaKeys']] = None,
        optional: Optional[Iterable['types.SequelizeMetaKeys']] = None,
        relations: Optional[Mapping['types.SequelizeMetaRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.SequelizeMetaKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _SequelizeMeta_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _SequelizeMeta_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _SequelizeMeta_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _SequelizeMeta_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True


            if relations:
                raise ValueError('Model: "SequelizeMeta" has no relational fields.')
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid SequelizeMeta / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'SequelizeMeta',
            }
        )
        _created_partial_types.add(name)


class Users(bases.BaseUsers):
    """Represents a Users record"""

    id: _int
    nome_completo: Optional[_str] = None
    email: Optional[_str] = None
    pin_acesso: Optional[_str] = None
    telefone: Optional[_str] = None
    type: Optional['enums.enum_Users_type'] = None
    bi: Optional[_str] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    Vigilantes: Optional[List['models.Vigilantes']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.UsersKeys']] = None,
        exclude: Optional[Iterable['types.UsersKeys']] = None,
        required: Optional[Iterable['types.UsersKeys']] = None,
        optional: Optional[Iterable['types.UsersKeys']] = None,
        relations: Optional[Mapping['types.UsersRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.UsersKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Users_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Users_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Users_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Users_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Users_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Users_relational_fields:
                        raise errors.UnknownRelationalFieldError('Users', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Users / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Users',
            }
        )
        _created_partial_types.add(name)


class Vigilantes(bases.BaseVigilantes):
    """Represents a Vigilantes record"""

    id: _int
    turno: 'enums.enum_Vigilantes_turno'
    descricao: Optional[_str] = None
    UserId: Optional[_int] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    Users: Optional['models.Users'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.VigilantesKeys']] = None,
        exclude: Optional[Iterable['types.VigilantesKeys']] = None,
        required: Optional[Iterable['types.VigilantesKeys']] = None,
        optional: Optional[Iterable['types.VigilantesKeys']] = None,
        relations: Optional[Mapping['types.VigilantesRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.VigilantesKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Vigilantes_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Vigilantes_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Vigilantes_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Vigilantes_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Vigilantes_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Vigilantes_relational_fields:
                        raise errors.UnknownRelationalFieldError('Vigilantes', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Vigilantes / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Vigilantes',
            }
        )
        _created_partial_types.add(name)



_Alunos_relational_fields: Set[str] = {
        'Alunos_propina',
        'Fotos',
        'Historico',
        'Reconhecimento',
    }
_Alunos_fields: Dict['types.AlunosKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('n_do_processo', {
            'name': 'n_do_processo',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('nome_completo', {
            'name': 'nome_completo',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('classe', {
            'name': 'classe',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('turno', {
            'name': 'turno',
            'is_list': False,
            'optional': False,
            'type': 'enums.enum_Alunos_turno',
            'is_relational': False,
            'documentation': None,
        }),
        ('ano_letivo', {
            'name': 'ano_letivo',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('turma', {
            'name': 'turma',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('curso', {
            'name': 'curso',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('Alunos_propina', {
            'name': 'Alunos_propina',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Alunos_propina\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('Fotos', {
            'name': 'Fotos',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Fotos\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('Historico', {
            'name': 'Historico',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Historico\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('Reconhecimento', {
            'name': 'Reconhecimento',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Reconhecimento\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Alunos_propina_relational_fields: Set[str] = {
        'Alunos',
        'Propinas',
    }
_Alunos_propina_fields: Dict['types.Alunos_propinaKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('alunoId', {
            'name': 'alunoId',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('propinaId', {
            'name': 'propinaId',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('valor', {
            'name': 'valor',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('Alunos', {
            'name': 'Alunos',
            'is_list': False,
            'optional': True,
            'type': 'models.Alunos',
            'is_relational': True,
            'documentation': None,
        }),
        ('Propinas', {
            'name': 'Propinas',
            'is_list': False,
            'optional': True,
            'type': 'models.Propinas',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Fotos_relational_fields: Set[str] = {
        'Alunos',
    }
_Fotos_fields: Dict['types.FotosKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('descricao', {
            'name': 'descricao',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('url', {
            'name': 'url',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('alunoId', {
            'name': 'alunoId',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('Alunos', {
            'name': 'Alunos',
            'is_list': False,
            'optional': True,
            'type': 'models.Alunos',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Historico_relational_fields: Set[str] = {
        'Alunos',
        'Propinas',
    }
_Historico_fields: Dict['types.HistoricoKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('alunoId', {
            'name': 'alunoId',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('propinaId', {
            'name': 'propinaId',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': False,
            'type': 'enums.enum_Historico_status',
            'is_relational': False,
            'documentation': None,
        }),
        ('timestamp', {
            'name': 'timestamp',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('Alunos', {
            'name': 'Alunos',
            'is_list': False,
            'optional': True,
            'type': 'models.Alunos',
            'is_relational': True,
            'documentation': None,
        }),
        ('Propinas', {
            'name': 'Propinas',
            'is_list': False,
            'optional': True,
            'type': 'models.Propinas',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Propinas_relational_fields: Set[str] = {
        'Alunos_propina',
        'Historico',
    }
_Propinas_fields: Dict['types.PropinasKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('mes', {
            'name': 'mes',
            'is_list': False,
            'optional': False,
            'type': 'enums.enum_Propinas_mes',
            'is_relational': False,
            'documentation': None,
        }),
        ('ano_lectivo', {
            'name': 'ano_lectivo',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('Alunos_propina', {
            'name': 'Alunos_propina',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Alunos_propina\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('Historico', {
            'name': 'Historico',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Historico\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Reconhecimento_relational_fields: Set[str] = {
        'Alunos',
    }
_Reconhecimento_fields: Dict['types.ReconhecimentoKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('alunoId', {
            'name': 'alunoId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('Alunos', {
            'name': 'Alunos',
            'is_list': False,
            'optional': True,
            'type': 'models.Alunos',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_SequelizeMeta_relational_fields: Set[str] = set()  # pyright: ignore[reportUnusedVariable]
_SequelizeMeta_fields: Dict['types.SequelizeMetaKeys', PartialModelField] = OrderedDict(
    [
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_Users_relational_fields: Set[str] = {
        'Vigilantes',
    }
_Users_fields: Dict['types.UsersKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('nome_completo', {
            'name': 'nome_completo',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('email', {
            'name': 'email',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('pin_acesso', {
            'name': 'pin_acesso',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('telefone', {
            'name': 'telefone',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('type', {
            'name': 'type',
            'is_list': False,
            'optional': True,
            'type': 'enums.enum_Users_type',
            'is_relational': False,
            'documentation': None,
        }),
        ('bi', {
            'name': 'bi',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('Vigilantes', {
            'name': 'Vigilantes',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Vigilantes\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Vigilantes_relational_fields: Set[str] = {
        'Users',
    }
_Vigilantes_fields: Dict['types.VigilantesKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('turno', {
            'name': 'turno',
            'is_list': False,
            'optional': False,
            'type': 'enums.enum_Vigilantes_turno',
            'is_relational': False,
            'documentation': None,
        }),
        ('descricao', {
            'name': 'descricao',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('UserId', {
            'name': 'UserId',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('Users', {
            'name': 'Users',
            'is_list': False,
            'optional': True,
            'type': 'models.Users',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)



# we have to import ourselves as relation types are namespaced to models
# e.g. models.Post
from . import models, actions

# required to support relationships between models
model_rebuild(Alunos)
model_rebuild(Alunos_propina)
model_rebuild(Fotos)
model_rebuild(Historico)
model_rebuild(Propinas)
model_rebuild(Reconhecimento)
model_rebuild(SequelizeMeta)
model_rebuild(Users)
model_rebuild(Vigilantes)
